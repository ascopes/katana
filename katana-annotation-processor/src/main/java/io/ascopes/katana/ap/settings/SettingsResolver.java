package io.ascopes.katana.ap.settings;

import io.ascopes.katana.annotations.ImmutableModel;
import io.ascopes.katana.annotations.MutableModel;
import io.ascopes.katana.annotations.Settings;
import io.ascopes.katana.ap.iterators.PackageIterator;
import io.ascopes.katana.ap.iterators.SupertypeIterator;
import io.ascopes.katana.ap.settings.gen.SettingsCollection;
import io.ascopes.katana.ap.settings.gen.SettingsSchemas;
import io.ascopes.katana.ap.utils.AnnotationUtils;
import io.ascopes.katana.ap.utils.Functors;
import io.ascopes.katana.ap.utils.Result;
import java.util.List;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.AnnotationValue;
import javax.lang.model.element.Element;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import org.checkerframework.checker.optional.qual.MaybePresent;

/**
 * Resolver for processor settings. This contains a load of reflection evil to simplify the
 * specification for new settings. The internal parts of API is fragile so be very careful with it.
 *
 * @author Ashley Scopes
 * @since 0.0.1
 */
public final class SettingsResolver {

  private final Elements elementUtils;
  private final Types typeUtils;

  /**
   * Initialize this resolver.
   *
   * @param elementUtils the element utilities to use for introspection.
   * @param typeUtils    the type utilities to use for introspection.
   */
  public SettingsResolver(Elements elementUtils, Types typeUtils) {
    this.elementUtils = elementUtils;
    this.typeUtils = typeUtils;
  }

  /**
   * Parse settings for a given annotated interface and model type mirror (i.e. {@link
   * ImmutableModel} or {@link MutableModel}). Consider all superinterfaces and all super-packages
   * with {@link Settings} on them, as well as the {@link Settings} within the model annotation
   * itself.
   *
   * <p>Parse the settings using the generated schemas from the Maven build (see the groovy script)
   * and collect them into a generated instance of {@link SettingsCollection}.
   *
   * @param interfaceElement the interface to generate the model from.
   * @param annotationMirror the model annotation.
   * @param mutable          true if a mutable model definition, false if immutable.
   * @return an OK result containing the parsed settings, or a failed result if resolution failed.
   */
  public Result<SettingsCollection> parseSettings(
      TypeElement interfaceElement,
      AnnotationMirror annotationMirror,
      boolean mutable
  ) {
    List<SettingsAnnotation> allEntries = this.allEntriesFor(interfaceElement, annotationMirror,
        mutable
    );

    // Generated by src/gen/groovy/GenerateSettingsBoilerplate.groovy based on the attributes in
    // the @Settings annotation.
    SettingsCollection.Builder builder = SettingsCollection.builder();

    // Generated by src/gen/groovy/GenerateSettingsBoilerplate.groovy based on the attributes in
    // the @Settings annotation.
    SettingsSchemas
        .schemas()
        .map(schema -> this.wrappedDetermineSettingFor(schema, mutable, allEntries))
        .forEach(setting -> setting.getSettingSchema().getBuilderSetter().accept(builder, setting));

    return Result.ok(builder.build());
  }

  private List<SettingsAnnotation> allEntriesFor(
      TypeElement interfaceElement,
      AnnotationMirror annotationMirror,
      boolean mutable
  ) {
    Stream<SettingsAnnotation> modelAnnotationEntries = this
        .findSettingsOnAnnotation(interfaceElement, annotationMirror)
        .map(Stream::of)
        .orElseGet(Stream::empty);

    Stream<SettingsAnnotation> interfaceEntries =
        new SupertypeIterator(this.typeUtils, interfaceElement)
            .stream()
            .map(this::findSettingsOnTypeElement)
            .flatMap(Functors.removeEmpties());

    Stream<SettingsAnnotation> packageEntries =
        new PackageIterator(this.elementUtils, interfaceElement)
            .stream()
            .flatMap(packageElement -> this.findSettingsOnPackage(packageElement, mutable));

    return Stream
        .of(modelAnnotationEntries, interfaceEntries, packageEntries)
        .flatMap(Functors.flattenStream())
        .collect(Collectors.toList());
  }

  private <T> Setting<T> wrappedDetermineSettingFor(
      SettingSchema<T> schema,
      boolean mutable,
      List<SettingsAnnotation> annotations
  ) {
    try {
      return this.determineSettingFor(schema, mutable, annotations);
    } catch (Exception ex) {
      throw new RuntimeException("Failed to parse setting " + schema.getName(), ex);
    }
  }

  private <T> Setting<T> determineSettingFor(
      SettingSchema<T> schema,
      boolean mutable,
      List<SettingsAnnotation> annotations
  ) {
    for (SettingsAnnotation annotation : annotations) {
      Optional<? extends AnnotationValue> possibleAnnotationValue = AnnotationUtils
          .getValue(annotation.mirror, schema.getName());
      Optional<T> possibleValue = possibleAnnotationValue
          .map(AnnotationValue::getValue)
          .map(this::unwrapValue)
          .map(schema.getParameterizedTypeish()::cast);

      if (!possibleAnnotationValue.isPresent() || !possibleValue.isPresent()) {
        // Attributes left unspecified are assumed to be inherited.
        continue;
      }

      T actualValue = possibleValue.get();

      String description = "setting '" + schema.getName() + "' with"
          + " value '" + actualValue + "'"
          + ", from " + annotation.description;

      // We found the setting, so return it.
      SettingValueHolder<T> valueHolder = new SettingValueHolder<>(
          actualValue,
          annotation.declaringElement,
          annotation.mirror,
          possibleAnnotationValue.get()
      );

      return new Setting<>(
          valueHolder,
          description,
          schema
      );
    }

    T defaultValue = mutable
        ? schema.getMutableDefaultValue()
        : schema.getImmutableDefaultValue();

    String description = "default Katana setting '" + schema.getName() + "'";

    return new Setting<>(new SettingValueHolder<>(defaultValue), description, schema);
  }

  @MaybePresent
  private Optional<SettingsAnnotation> findSettingsOnAnnotation(
      Element declaringElement,
      AnnotationMirror annotationMirror
  ) {
    return annotationMirror
        .getElementValues()
        .entrySet()
        .stream()
        .filter(pair -> pair.getKey().getSimpleName().contentEquals("value"))
        .findAny()
        .map(Entry::getValue)
        .map(AnnotationValue::getValue)
        .map(AnnotationMirror.class::cast)
        .map(settings ->
            new SettingsAnnotation(
                "annotation applied to your usage of @" + annotationMirror
                    .getAnnotationType()
                    .asElement()
                    .getSimpleName(),
                declaringElement,
                settings
            ));
  }

  @MaybePresent
  private Optional<SettingsAnnotation> findSettingsOnTypeElement(TypeElement typeElement) {
    return this
        .findSettingsOn(
            typeElement,
            "annotation on class '" + typeElement.getQualifiedName() + "'"
        );
  }

  private Stream<SettingsAnnotation> findSettingsOnPackage(
      PackageElement packageElement,
      boolean mutable
  ) {
    Optional<SettingsAnnotation> allModelsSettings = this.findSettingsOn(
        packageElement,
        "annotation on package '" + packageElement.getQualifiedName() + "'"
    );

    String mutabilityAnnotationName = mutable
        ? MutableModel.class.getCanonicalName()
        : ImmutableModel.class.getCanonicalName();

    TypeElement mutabilityAnnotation = this.elementUtils.getTypeElement(mutabilityAnnotationName);

    // Find a usage of @MutableModel(@Settings(...)) or @ImmutableModel(@Settings(...)) on the
    // package level.
    Optional<SettingsAnnotation> mutabilitySpecificSettings = AnnotationUtils
        .findAnnotationMirror(packageElement, mutabilityAnnotation)
        .flatMap(mirror -> this.findSettingsOnAnnotation(packageElement, mirror));

    return Stream
        .of(allModelsSettings, mutabilitySpecificSettings)
        .flatMap(Functors.removeEmpties());
  }

  @MaybePresent
  private Optional<SettingsAnnotation> findSettingsOn(
      Element annotatedElement,
      String qualifiedName
  ) {
    return annotatedElement
        .getAnnotationMirrors()
        .stream()
        .filter(this::isSettingsAnnotationMirror)
        .findAny()
        .map(settings -> new SettingsAnnotation(qualifiedName, annotatedElement, settings));
  }

  private boolean isSettingsAnnotationMirror(AnnotationMirror mirror) {
    return mirror
        .getAnnotationType()
        .asElement()
        .getSimpleName()
        .contentEquals(Settings.class.getSimpleName());
  }

  private Object unwrapValue(Object value) {
    // Represents a value of an annotation type element. A value is of one of the following types:
    //    - a wrapper class (such as Integer) for a primitive type
    //    - String
    //    - TypeMirror
    //    - VariableElement (representing an enum constant)
    //    - AnnotationMirror
    //    - List<? extends AnnotationValue> (representing the elements, in declared order, if the
    //        value is an array)

    if (value instanceof List) {
      return ((List<?>) value)
          .stream()
          .map(this::unwrapValue)
          .collect(Collectors.toList());
    }

    if (value instanceof VariableElement) {
      VariableElement enumValue = (VariableElement) value;
      DeclaredType declaredType = (DeclaredType) enumValue.asType();
      TypeElement typeElement = (TypeElement) declaredType.asElement();
      String className = typeElement.getQualifiedName().toString();
      String memberName = enumValue.getSimpleName().toString();

      try {
        @SuppressWarnings("unchecked")
        Class<Enum<?>> enumClass = (Class<Enum<?>>) Class.forName(className);
        for (Enum<?> member : enumClass.getEnumConstants()) {
          if (member.name().equals(memberName)) {
            return member;
          }
        }

        throw new RuntimeException("Could not find member " + memberName + " in enum " + className);
      } catch (ClassNotFoundException ex) {
        throw new RuntimeException("Could not load class for " + className);
      }
    }

    if (value instanceof AnnotationMirror) {
      // XXX: implement?
      throw new UnsupportedOperationException("Cannot unwrap annotation mirror types just yet");
    }

    return value;
  }

  /*
   * A single set of settings, from a specific location. This is just used as an intermediary
   * value while reading in settings.
   */
  private static final class SettingsAnnotation {

    private final String description;
    private final Element declaringElement;
    private final AnnotationMirror mirror;

    public SettingsAnnotation(
        String description,
        Element declaringElement,
        AnnotationMirror mirror
    ) {
      this.description = Objects.requireNonNull(description);
      this.declaringElement = Objects.requireNonNull(declaringElement);
      this.mirror = Objects.requireNonNull(mirror);
    }
  }
}
